A native NodeJS module using Typescript
=======================================
### Summary
* [Install and run](#install)
* [Documentation](#documentation)
    * [`electron_sample` application](#electron_sample)
    * [`native_module` module](#native_module)
    

<a href="#install"></a> Install and run
---------------
Install NodeJS.

From an elevated PowerShell or CMD.exe (run as Administrator), run
``` bash
$ npm install --global --production windows-build-tools
```
to install Python and Visual C++ Build Environment.

After that, in the project folder launch
``` bash
$ cd native_module && npm install && npm run build
$ cd .. && cd electron_sample && npm install && npm run build
$ npm run start
```

After the `start` task, the native string `world` will appear inside the DOM.

<a href="#documentation"></a> Documentation
-------------
The application is split in two parts:

* **`electron_sample`**:  a sample application running in Electron using a Typescript renderer.
* **`native_module`**: a sample Typescript module that integrates a native feature.

In order to display the sample string generated by the module in the Electron application, we need to inject it into 
the application itself.

### <a href="#electron_sample"></a> `electron_sample` application

The application main treat is to generate an Electron application and to include the `native_module`.

The assets file are already moved in the `dist` folder and webpack is configured to build the bundle inside that folder.

The application `package.json` just includes the local path in his dependencies.
```
"dependencies": {
    "native_module": "file:../native_module"
}
```
`devDependencies` are included to compile and run correctly the application.

In our `scripts` we have:
* `start` task, to launch the application.
* `postinstall` task, to rebuild Electron including the native module.
* `build` task, to compile and pack Typescript and Javascript files.

### <a href="#native_module"></a> `native_module` module
First of all, let's consider the `tsconfig.json` file. Using:
```
"declaration": true,
"outDir": "dist"
```
the Typescript compiler will use `dist` as the build directory and will generate declarations.

In the `package.json`
``` 
"main": "dist/index.js",
"types": "dist/index.d.ts"
```
indicates the correct path for the main file and typings.

The scripts used in this module are
``` 
"build": "npm run build-native && npm run tsc",
"tsc": "tsc",
"build-native": "node-gyp rebuild"
``` 
* `tsc`: compiles the Typescript source code.
* `build-native`: compiles the C++ code.
* `build`: executes both.

In order to develop using a native library, we need `nan` and `node-gyp`. `@types/node` and `typescript` are useful to
compile Typescript.
``` 
"dependencies": {
    "nan": "^2.0.0"
},
"devDependencies": {
    "@types/node": "^8.0.31",
    "node-gyp": "^3.6.2",
    "typescript": "^2.5.3"
}
``` 

In `binding.gyp` we include `nan` binaries
```
"include_dirs": [
    "<!(node -e \"require('nan')\")"
]
```

In Typescript `index.ts` is wrapped the exported `hello` function used in the Electron application.